<!DOCTYPE html>
<html lang="nl">

<head>
  <meta charset="UTF-8" />
  <title>Liturgie Dashboard</title>
  <link rel="stylesheet" href="/styles.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Urbanist:ital,wght@0,100..900;1,100..900&display=swap"
    rel="stylesheet">
  <style>
    .save-button-container {
      position: fixed;
      bottom: 30px;
      right: 30px;
      z-index: 1000;
    }

    .save-button {
      padding: 15px 30px;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
      font-family: "Urbanist", sans-serif;
    }

    .save-button:hover {
      background: #1d4ed8;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    }

    .save-button:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }

    .save-status {
      position: fixed;
      bottom: 90px;
      right: 30px;
      background: rgba(0, 0, 0, 0.8);
      color: #90ee90;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 1000;
      display: none;
      font-family: "Urbanist", sans-serif;
    }

    .save-status.show {
      display: block;
    }

    .liturgie-line[contenteditable="true"] {
      cursor: text;
      outline: 2px solid transparent;
      transition: outline 0.2s;
      white-space: nowrap;
    }

    .liturgie-line[contenteditable="true"]:focus {
      outline: 2px solid rgba(37, 99, 235, 0.5);
    }

    .liturgie-line[contenteditable="true"]:hover {
      outline: 2px solid rgba(37, 99, 235, 0.3);
    }
  </style>
</head>

<body>
  <div class="liturgie-container">
    <div id="liturgie" class="liturgie-tekst">
      Liturgie wordt geladen...
    </div>
  </div>

  <div class="save-button-container">
    <button id="save-button" class="save-button">Opslaan</button>
  </div>
  <div id="save-status" class="save-status"></div>

  <script>
    function styleLineContent(text) {
      return Array.from(text).map(char => {
        if (char === " ") {
          return `<span class="space">&nbsp;</span>`;
        }

        if (char === ":" || char === ";") {
          return `<span class="semicolon">${char}</span>`;
        }

        if (/^[a-z0-9]$/i.test(char)) {
          return `<span class="letter-block">${char}</span>`;
        }

        // Preserve any other characters visibly but in the neutral style
        return `<span class="space">${char}</span>`;
      }).join("");
    }

    function renderLiturgie(tekst) {
      const el = document.getElementById("liturgie");

      const textLines = tekst.split('\n').map(line => {
        if (line.trim() === "") {
          return '<div class="liturgie-line" contenteditable="true">&nbsp;</div>';
        }

        return `<div class="liturgie-line" contenteditable="true">${styleLineContent(line)}</div>`;
      });

      // Calculate how many empty lines are needed to fill the viewport
      const lineHeight = 120 + 7; // min-height + border-bottom
      const viewportHeight = window.innerHeight;
      const contentHeight = textLines.length * lineHeight;
      const emptyLinesNeeded = Math.max(0, Math.ceil((viewportHeight - contentHeight) / lineHeight));

      // Add empty lines to fill the viewport
      const emptyLines = Array(emptyLinesNeeded).fill('<div class="liturgie-line" contenteditable="true">&nbsp;</div>');

      el.innerHTML = textLines.concat(emptyLines).join("");
    }

    function getCaretCharacterOffsetWithin(element) {
      const selection = window.getSelection();
      if (!selection.rangeCount) return null;
      const range = selection.getRangeAt(0);

      // If the cursor is directly in the line element (e.g. empty line)
      if (range.endContainer === element) {
        return range.endOffset;
      }

      let offset = 0;
      const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
      let node;

      while ((node = walker.nextNode())) {
        if (node === range.endContainer) {
          return offset + range.endOffset;
        }
        offset += node.textContent.length;
      }

      return null;
    }

    function setCaretAtOffset(element, offset) {
      const selection = window.getSelection();
      const range = document.createRange();
      let currentOffset = 0;

      const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
      let node;

      while ((node = walker.nextNode())) {
        const nextOffset = currentOffset + node.textContent.length;
        if (offset <= nextOffset) {
          range.setStart(node, offset - currentOffset);
          range.collapse(true);
          selection.removeAllRanges();
          selection.addRange(range);
          return;
        }
        currentOffset = nextOffset;
      }

      range.selectNodeContents(element);
      range.collapse(false);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    function applyStylingToLine(lineEl) {
      const caretOffset = getCaretCharacterOffsetWithin(lineEl);
      const text = lineEl.textContent.replace(/\u00a0/g, ' ');
      lineEl.innerHTML = text === "" ? "&nbsp;" : styleLineContent(text);
      if (caretOffset !== null) {
        setCaretAtOffset(lineEl, Math.min(caretOffset, lineEl.textContent.length));
      }
    }

    function extractTextFromLiturgie() {
      const el = document.getElementById("liturgie");
      const lines = el.querySelectorAll('.liturgie-line');
      const textLines = [];

      for (const line of lines) {
        const lineText = line.textContent.replace(/\u00a0/g, ' ');

        // Treat lines with only whitespace (including nbsp) as empty lines
        // This preserves empty lines when saving
        if (lineText.trim() === '') {
          textLines.push('');
        } else {
          textLines.push(lineText);
        }
      }

      // Remove trailing empty lines that are just viewport fillers
      while (textLines.length > 0 && textLines[textLines.length - 1] === '') {
        textLines.pop();
      }

      return textLines.join('\n');
    }

    async function laadLiturgie() {
      try {
        const res = await fetch("/api/get-liturgie");
        const data = await res.json();
        const tekst = data.tekst || "";
        renderLiturgie(tekst);
      } catch (err) {
        console.error(err);
        document.getElementById("liturgie").textContent = "Fout bij laden van de liturgie.";
      }
    }

    async function opslaanLiturgie() {
      const saveBtn = document.getElementById("save-button");
      const statusEl = document.getElementById("save-status");

      try {
        saveBtn.disabled = true;
        statusEl.textContent = "Bezig met opslaan...";
        statusEl.classList.add("show");

        const tekst = extractTextFromLiturgie();

        const res = await fetch("/api/set-liturgie", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ tekst: tekst })
        });

        const data = await res.json();

        if (data.ok) {
          statusEl.textContent = "Opgeslagen!";
          setTimeout(() => {
            statusEl.classList.remove("show");
          }, 3000);
        } else {
          statusEl.textContent = "Fout bij opslaan.";
          statusEl.style.color = "#ff6b6b";
        }
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Fout bij opslaan.";
        statusEl.style.color = "#ff6b6b";
      } finally {
        saveBtn.disabled = false;
      }
    }

    document.getElementById("save-button").addEventListener("click", opslaanLiturgie);

      // Live styling while typing
    document.getElementById("liturgie").addEventListener("input", function (e) {
      const targetLine = e.target.closest('.liturgie-line');
      if (targetLine) {
        applyStylingToLine(targetLine);
      }
    });

    // Block Enter to avoid creating new lines; support Arrow Up/Down to move between lines
    document.getElementById("liturgie").addEventListener("keydown", function (e) {
      if (e.key === "Enter") {
        e.preventDefault();
        return false;
      }

      if (e.key === "ArrowUp" || e.key === "ArrowDown") {
        const selection = window.getSelection();
        if (!selection.rangeCount) return;
        const range = selection.getRangeAt(0);

        let currentLine = range.startContainer;
        while (currentLine && !currentLine.classList?.contains("liturgie-line")) {
          currentLine = currentLine.parentNode;
        }

        if (!currentLine) return;

        const caretOffset = getCaretCharacterOffsetWithin(currentLine) ?? 0;
        const targetLine = e.key === "ArrowUp" ? currentLine.previousElementSibling : currentLine.nextElementSibling;

        if (targetLine && targetLine.classList.contains("liturgie-line")) {
          e.preventDefault();
          const targetLength = targetLine.textContent.length;
          setCaretAtOffset(targetLine, Math.min(caretOffset, targetLength));
        }
      }
    });

    laadLiturgie();
  </script>
</body>

</html>